<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H3 Exorcist Status Screen</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            transition: background-color 0.5s ease;
            font-family: arial;
            color: white;
            flex-direction: column;
        }

        .status-container {
            text-align: center;
            padding: 40px;
            border-radius: 10px;
            background-color: rgba(0, 0, 0, 0.2); /* Slight overlay for readability */
        }

        #status-text {
            font-size: 5em;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #countdown-timer {
            font-size: 3em;
            opacity: 0.8;
        }

        /* Color Classes (CSS Variables for dynamic background) */
        .blue { --bg-color: #000080; } /* Closed */
        .green { --bg-color: #006400; } /* Open */
        .red { --bg-color: #8B0000; } /* On Break */
        .purple { --bg-color: #4B0082; } /* On Dinner Break */
    </style>
</head>
<body class="blue">
    <div class="status-container">
        <div id="status-text">Checking Status...</div>
        <div id="countdown-timer"></div>
    </div>

    <script>
        // Define the operating schedule in 24-hour format
        // Times are in minutes from midnight (e.g., 2:30 PM is 14*60 + 30 = 870 minutes)
        // Times are inclusive of the start time, exclusive of the end time for these rules.
        const schedule = [
            // Define "Open" blocks (Green)
            { start: 870, end: 915, status: "H3 OPEN", color: "green" }, // 2:30 - 3:15
            { start: 930, end: 975, status: "H3 OPEN", color: "green" }, // 3:30 - 4:15
            { start: 990, end: 1035, status: "H3 OPEN", color: "green" }, // 4:30 - 5:15
            { start: 1080, end: 1125, status: "H3 OPEN", color: "green" }, // 6:00 - 6:45
            { start: 1140, end: 1185, status: "H3 OPEN", color: "green" }, // 7:00 - 7:45
            { start: 1200, end: 1245, status: "H3 OPEN", color: "green" }, // 8:00 - 8:45
            { start: 1260, end: 1305, status: "H3 OPEN", color: "green" }, // 9:00 - 9:45

            // Define "On Break" blocks (Red)
            { start: 915, end: 930, status: "H3 ON BREAK", color: "red" }, // 3:15 - 3:30
            { start: 975, end: 990, status: "H3 ON BREAK", color: "red" }, // 4:15 - 4:30
            { start: 1125, end: 1140, status: "H3 ON BREAK", color: "red" }, // 6:45 - 7:00
            { start: 1185, end: 1200, status: "H3 ON BREAK", color: "red" }, // 7:45 - 8:00
            { start: 1245, end: 1260, status: "H3 ON BREAK", color: "red" }, // 8:45 - 9:00

            // Define "On Dinner Break" block (Purple)
            { start: 1035, end: 1080, status: "H3 ON DINNER BREAK", color: "purple" }, // 5:15 - 6:00
        ];

        function updateStatus() {
            const now = new Date();
            // Get the time in minutes from midnight for easy comparison
            const currentTimeMinutes = now.getHours() * 60 + now.getMinutes();

            let currentStatus = { status: "H3 CLOSED", color: "blue" };
            let nextChangeTime = new Date(now);
            const openTimeStartToday = 870; // 2:30 PM
            const closeTimeEndToday = 1305; // 9:45 PM

            // 1. Check if we are within any specific scheduled time slot
            for (const slot of schedule) {
                if (currentTimeMinutes >= slot.start && currentTimeMinutes < slot.end) {
                    currentStatus = slot;
                    // Calculate the exact timestamp for the end of the current slot
                    const endHours = Math.floor(slot.end / 60);
                    const endMinutes = slot.end % 60;
                    nextChangeTime.setHours(endHours, endMinutes, 0, 0);
                    break; // Found the current slot, stop checking
                }
            }

            // 2. If we are "H3 CLOSED" (default status is maintained), find the next boundary
            if (currentStatus.status === "H3 CLOSED") {
                if (currentTimeMinutes < openTimeStartToday) {
                    // It is before 2:30 PM today, next change is 2:30 PM today
                    nextChangeTime.setHours(14, 30, 0, 0);
                } else if (currentTimeMinutes >= closeTimeEndToday) {
                    // It is after 9:45 PM today, next change is 2:30 PM tomorrow
                    nextChangeTime.setDate(now.getDate() + 1);
                    nextChangeTime.setHours(14, 30, 0, 0);
                }
            }

            applyStyle(currentStatus.status, currentStatus.color);
            startCountdown(nextChangeTime);
        }

        function applyStyle(statusText, colorClass) {
            document.body.className = colorClass;
            // Apply the CSS variable to the body for the transition effect
            document.body.style.backgroundColor = `var(--bg-color)`;
            document.getElementById('status-text').textContent = statusText;
        }

        function startCountdown(endTime) {
            const timerElement = document.getElementById('countdown-timer');
            // Clear any previous intervals if updateStatus is called multiple times
            if (window.countdownInterval) {
                clearInterval(window.countdownInterval);
            }

            function updateCountdown() {
                const now = new Date();
                let timeDifference = endTime - now;

                if (timeDifference <= 0) {
                    clearInterval(window.countdownInterval);
                    timerElement.textContent = "Status is updating now, please wait...";
                    // Recalculate everything when the timer hits zero
                    setTimeout(updateStatus, 1000); // Give it a second before updating
                    return;
                }

                const hours = Math.floor((timeDifference % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((timeDifference % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((timeDifference % (1000 * 60)) / 1000);

                const formatTime = value => value < 10 ? `0${value}` : value;

                timerElement.textContent = `${formatTime(hours)}:${formatTime(minutes)}:${formatTime(seconds)} left`;
            }

            // Update countdown every second
            window.countdownInterval = setInterval(updateCountdown, 1000);
            updateCountdown(); // Call immediately to avoid a 1-second delay
        }

        // Initialize the script
        updateStatus();
    </script>
</body>
</html>